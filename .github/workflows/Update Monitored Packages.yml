name: Update Monitored Packages

on:
  schedule:
    # Check daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch: # Allow manual triggering

permissions:
  contents: write

jobs:
  check-and-update-msal:
    runs-on: windows-latest

# Implement skip on forks (if: github.repository_owner == 'SamErde')

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          fetch-depth: 0

      - name: Check for package updates
        id: check_packages
        shell: pwsh
        run: |
          # Set initial defaults.
          $LibPath = Join-Path -Path $env:GITHUB_WORKSPACE -ChildPath "src/DLLPickle/Lib"
          $JsonPath = Join-Path -Path $LibPath -ChildPath "Packages.json"

          # Read package tracking JSON
          if (-not (Test-Path $JsonPath)) {
              Write-Error "Package tracking JSON not found at $JsonPath"
              exit 1
          }

          $PackageTracking = Get-Content $JsonPath -Raw | ConvertFrom-Json
          $UpdatesAvailable = $false
          $UpdateSummary = @()

          # Check each package version for updates.
          foreach ($Package in $PackageTracking.packages) {
              Write-Host "`n=== Checking $($Package.name) ===" -ForegroundColor Cyan

              $CurrentVersion = $Package.version
              Write-Host "Current version: $CurrentVersion"

              # Check the latest version from NuGet.
              $NuGetUrl = "https://api.nuget.org/v3-registration5-semver1/$($Package.name.ToLower())/index.json"
              try {
                  $Response = Invoke-RestMethod -Uri $NuGetUrl -ErrorAction Stop
                  $LatestVersion = $Response.items[-1].upper
                  Write-Host "Latest version: $LatestVersion"

                  if ([version]$LatestVersion -gt [version]$CurrentVersion) {
                      Write-Host "✓ Update available!" -ForegroundColor Green
                      $UpdatesAvailable = $true
                      $UpdateSummary += "$($Package.name): $CurrentVersion → $LatestVersion"
                  } else {
                      Write-Host "Already up to date" -ForegroundColor Gray
                  }
              } catch {
                  Write-Warning "Failed to check $($Package.name): $_"
              }
          }

          if ($UpdatesAvailable) {
              "updates_available=true" >> $env:GITHUB_OUTPUT
              $SummaryText = $UpdateSummary -join "; "
              "update_summary=$SummaryText" >> $env:GITHUB_OUTPUT
          } else {
              "updates_available=false" >> $env:GITHUB_OUTPUT
          }

      - name: Download and extract packages
        if: steps.check_packages.outputs.updates_available == 'true'
        shell: pwsh
        run: |
          $LibPath = Join-Path -Path $env:GITHUB_WORKSPACE -ChildPath "src/DLLPickle/Lib"
          New-Item -ItemType Directory -Path $LibPath -Force | Out-Null

          # Read package tracking JSON
          $JsonPath = Join-Path -Path $LibPath -ChildPath "Packages.json"
          if (-not (Test-Path $JsonPath)) {
              Write-Error "Package tracking JSON not found at $JsonPath"
              exit 1
          }

          $PackageTracking = Get-Content $JsonPath -Raw | ConvertFrom-Json
          $UpdatedPackages = $false

          # Create temp directory
          $TempDir = Join-Path $env:TEMP "msal_update"
          if (Test-Path $TempDir) {
              Remove-Item $TempDir -Recurse -Force
          }
          New-Item -ItemType Directory -Path $TempDir -Force | Out-Null

          foreach ($Package in $PackageTracking.packages) {
              Write-Host "`n=== Processing $($Package.name) ===" -ForegroundColor Cyan

              $CurrentVersion = $Package.version
              Write-Host "Current version: $CurrentVersion"

              # Get latest version
              $NuGetUrl = "https://api.nuget.org/v3-registration5-semver1/$($Package.name.ToLower())/index.json"
              try {
                  $Response = Invoke-RestMethod -Uri $NuGetUrl -ErrorAction Stop
                  $LatestVersion = $Response.items[-1].upper

                  if ([version]$LatestVersion -gt [version]$CurrentVersion) {
                      Write-Host "Downloading version $LatestVersion..."

                      # Download package
                      $DownloadUrl = "https://www.nuget.org/api/v2/package/$($Package.name)/$LatestVersion"
                      $NupkgPath = Join-Path $TempDir "$($Package.name).$LatestVersion.nupkg"
                      Invoke-WebRequest -Uri $DownloadUrl -OutFile $NupkgPath -ErrorAction Stop

                      # Extract (nupkg is just a zip)
                      $ExtractPath = Join-Path $TempDir "$($Package.name)_extracted"
                      Expand-Archive -Path $NupkgPath -DestinationPath $ExtractPath -Force

                      # Try multiple framework paths in order of preference
                      $FrameworkPaths = @(
                          "lib\netstandard2.0\*.dll",
                          "lib\netstandard2.1\*.dll",
                          "lib\net6.0\*.dll",
                          "lib\net472\*.dll",
                          "runtimes\win\lib\netstandard2.0\*.dll",
                          "runtimes\win\lib\net6.0\*.dll"
                      )

                      $DllsCopied = $false
                      foreach ($FwPath in $FrameworkPaths) {
                          $SourceDlls = Join-Path $ExtractPath $FwPath
                          $DllFiles = Get-Item $SourceDlls -ErrorAction SilentlyContinue
                          if ($DllFiles) {
                              Write-Host "Copying DLLs from $FwPath..."
                              Copy-Item -Path $SourceDlls -Destination $LibPath -Force
                              $DllsCopied = $true
                              break
                          }
                      }

                      if (-not $DllsCopied) {
                          Write-Warning "No compatible DLLs found for $($Package.name)"
                      } else {
                          # Update version in JSON tracking
                          $Package.version = $LatestVersion
                          $UpdatedPackages = $true
                          Write-Host "✓ $($Package.name) $LatestVersion extracted successfully" -ForegroundColor Green
                      }
                  } else {
                      Write-Host "Already up to date" -ForegroundColor Gray
                  }
              } catch {
                  Write-Warning "Failed to process $($Package.name): $_"
              }
          }

          # Save updated JSON if any packages were updated
          if ($UpdatedPackages) {
              $PackageTracking | ConvertTo-Json -Depth 10 | Set-Content -Path $JsonPath -NoNewline
              Write-Host "`n✓ Updated package tracking JSON" -ForegroundColor Green
          }

          # Cleanup temp directory
          if (Test-Path $TempDir) {
              Remove-Item $TempDir -Recurse -Force
          }

      - name: Update module manifest
        id: update_module_manifest
        if: steps.check_packages.outputs.updates_available == 'true'
        shell: pwsh
        run: |
          $ManifestPath = Join-Path -Path $env:GITHUB_WORKSPACE -ChildPath "src/DLLPickle/DLLPickle.psd1"

          # Read current manifest
          $Manifest = Import-PowerShellDataFile -Path $ManifestPath
          $CurrentModuleVersion = [version]$Manifest.ModuleVersion

          # Increment patch version
          $NewModuleVersion = "{0}.{1}.{2}" -f $CurrentModuleVersion.Major, $CurrentModuleVersion.Minor, ($CurrentModuleVersion.Build + 1)

          # Update manifest
          Update-ModuleManifest -Path $ManifestPath -ModuleVersion $NewModuleVersion

          Write-Host "Updated module version to $NewModuleVersion"
          "new_module_version=$NewModuleVersion" >> $env:GITHUB_OUTPUT

      - name: Commit and push changes
        if: steps.check_packages.outputs.updates_available == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add src/DLLPickle/Lib/*.dll src/DLLPickle/Lib/Packages.json src/DLLPickle/DLLPickle.psd1
          git commit -m "Update MSAL packages: ${{ steps.check_packages.outputs.update_summary }}"
          git push

      - name: Create GitHub Release
        if: steps.check_packages.outputs.updates_available == 'true'
        uses: softprops/action-gh-release@5be0e66d93ac7ed76da52eca8bb058f665c3a5fe # v2.4.2
        with:
          tag_name: v${{ steps.update_module_manifest.outputs.new_module_version }}
          name: Release v${{ steps.update_module_manifest.outputs.new_module_version }}
          body: |
            ## MSAL Package Updates

            ${{ steps.check_packages.outputs.update_summary }}

            This release includes updated MSAL dependencies to ensure compatibility and security.
          draft: false
          prerelease: false
          token: ${{ secrets.GITHUB_TOKEN }}

#      - name: Publish to PowerShell Gallery
#        if: steps.check_packages.outputs.updates_available == 'true'
#        shell: pwsh
#        run: |
#          Publish-Module -Path . -NuGetApiKey ${{ secrets.PSGALLERY_API_KEY }}
#          Write-Host "Module published to PowerShell Gallery"
