name: Update Dependencies

on:
  schedule:
    # Check daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch: # Allow manual triggering

# Prevent concurrent dependency update runs
concurrency:
  group: update-dependencies
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write

jobs:
  check-and-update:
    # Only run on the main repository, not forks
    if: github.repository_owner == 'SamErde'
    runs-on: windows-latest

    steps:
      - name: Harden the runner (Audit all outbound calls)
        uses: step-security/harden-runner@20cf305ff2072d973412fa9b1e3a4f227bda3c76 # v2.14.0
        with:
          egress-policy: audit

      - name: Checkout repository
        uses: actions/checkout@8e8c483db84b4bee98b60c0593521ed34d9990e8 # v6.0.1
        with:
          fetch-depth: 0

      - name: Check for package updates
        id: check_packages
        shell: pwsh
        run: |
          # Set initial defaults.
          $LibPath = Join-Path -Path $env:GITHUB_WORKSPACE -ChildPath "src/DLLPickle/Lib"
          $JsonPath = Join-Path -Path $LibPath -ChildPath "Packages.json"

          # Read package tracking JSON
          if (-not (Test-Path $JsonPath)) {
              Write-Error "Package tracking JSON not found at $JsonPath"
              exit 1
          }

          $PackageTracking = Get-Content $JsonPath -Raw | ConvertFrom-Json
          $UpdatesAvailable = $false
          $UpdateSummary = @()

          # Check each package version for updates.
          foreach ($Package in $PackageTracking.packages) {
              Write-Host "`n=== Checking $($Package.name) ===" -ForegroundColor Cyan

              $CurrentVersion = $Package.version
              Write-Host "Current version: $CurrentVersion"

              # Check the latest version from NuGet.
              $NuGetUrl = "https://api.nuget.org/v3-registration5-semver1/$($Package.name.ToLower())/index.json"
              try {
                  $Response = Invoke-RestMethod -Uri $NuGetUrl -ErrorAction Stop
                  $LatestVersion = $Response.items[-1].upper
                  Write-Host "Latest version: $LatestVersion"

                  if ([version]$LatestVersion -gt [version]$CurrentVersion) {
                      Write-Host "âœ“ Update available!" -ForegroundColor Green
                      $UpdatesAvailable = $true
                      $UpdateSummary += "$($Package.name): $CurrentVersion â†’ $LatestVersion"
                  } else {
                      Write-Host "Already up to date" -ForegroundColor Gray
                  }
              } catch {
                  Write-Warning "Failed to check $($Package.name): $_"
              }
          }

          if ($UpdatesAvailable) {
              "updates_available=true" >> $env:GITHUB_OUTPUT
              $SummaryText = $UpdateSummary -join "; "
              "update_summary=$SummaryText" >> $env:GITHUB_OUTPUT
          } else {
              "updates_available=false" >> $env:GITHUB_OUTPUT
          }

      - name: Download and extract packages
        if: steps.check_packages.outputs.updates_available == 'true'
        shell: pwsh
        run: |
          $LibPath = Join-Path -Path $env:GITHUB_WORKSPACE -ChildPath "src/DLLPickle/Lib"
          New-Item -ItemType Directory -Path $LibPath -Force | Out-Null

          # Read package tracking JSON
          $JsonPath = Join-Path -Path $LibPath -ChildPath "Packages.json"
          if (-not (Test-Path $JsonPath)) {
              Write-Error "Package tracking JSON not found at $JsonPath"
              exit 1
          }

          $PackageTracking = Get-Content $JsonPath -Raw | ConvertFrom-Json
          $UpdatedPackages = $false

          # Create temp directory
          $TempDir = Join-Path $env:TEMP "package_update"
          if (Test-Path $TempDir) {
              Remove-Item $TempDir -Recurse -Force
          }
          New-Item -ItemType Directory -Path $TempDir -Force | Out-Null

          foreach ($Package in $PackageTracking.packages) {
              Write-Host "`n=== Processing $($Package.name) ===" -ForegroundColor Cyan

              $CurrentVersion = $Package.version
              Write-Host "Current version: $CurrentVersion"

              # Get latest version
              $NuGetUrl = "https://api.nuget.org/v3-registration5-semver1/$($Package.name.ToLower())/index.json"
              try {
                  $Response = Invoke-RestMethod -Uri $NuGetUrl -ErrorAction Stop
                  $LatestVersion = $Response.items[-1].upper

                  if ([version]$LatestVersion -gt [version]$CurrentVersion) {
                      Write-Host "Downloading version $LatestVersion..."

                      # Download package
                      $DownloadUrl = "https://www.nuget.org/api/v2/package/$($Package.name)/$LatestVersion"
                      $NupkgPath = Join-Path $TempDir "$($Package.name).$LatestVersion.nupkg"
                      Invoke-WebRequest -Uri $DownloadUrl -OutFile $NupkgPath -ErrorAction Stop

                      # Extract (nupkg is just a zip)
                      $ExtractPath = Join-Path $TempDir "$($Package.name)_extracted"
                      Expand-Archive -Path $NupkgPath -DestinationPath $ExtractPath -Force

                      # Try multiple framework paths in order of preference
                      $FrameworkPaths = @(
                          "lib\netstandard2.0\*.dll",
                          "lib\netstandard2.1\*.dll",
                          "lib\net6.0\*.dll",
                          "lib\net472\*.dll",
                          "runtimes\win\lib\netstandard2.0\*.dll",
                          "runtimes\win\lib\net6.0\*.dll"
                      )

                      $DllsCopied = $false
                      foreach ($FwPath in $FrameworkPaths) {
                          $SourceDlls = Join-Path $ExtractPath $FwPath
                          $DllFiles = Get-Item $SourceDlls -ErrorAction SilentlyContinue
                          if ($DllFiles) {
                              Write-Host "Copying DLLs from $FwPath..."
                              Copy-Item -Path $SourceDlls -Destination $LibPath -Force
                              $DllsCopied = $true
                              break
                          }
                      }

                      if (-not $DllsCopied) {
                          Write-Warning "No compatible DLLs found for $($Package.name)"
                      } else {
                          # Update version in JSON tracking
                          $Package.version = $LatestVersion
                          $UpdatedPackages = $true
                          Write-Host "âœ“ $($Package.name) $LatestVersion extracted successfully" -ForegroundColor Green
                      }
                  } else {
                      Write-Host "Already up to date" -ForegroundColor Gray
                  }
              } catch {
                  Write-Warning "Failed to process $($Package.name): $_"
              }
          }

          # Save updated JSON if any packages were updated
          if ($UpdatedPackages) {
              $PackageTracking | ConvertTo-Json -Depth 10 | Set-Content -Path $JsonPath -NoNewline
              Write-Host "`nâœ“ Updated package tracking JSON" -ForegroundColor Green
          }

          # Cleanup temp directory
          if (Test-Path $TempDir) {
              Remove-Item $TempDir -Recurse -Force
          }

      - name: Check for existing PR
        if: steps.check_packages.outputs.updates_available == 'true'
        id: check_pr
        shell: pwsh
        env:
          GH_TOKEN: ${{ secrets.PAT_TOKEN }}
        run: |
          $branchName = "chore/update-packages"

          # Check if PR already exists
          $existingPR = gh pr list --head $branchName --state open --json number,title | ConvertFrom-Json

          if ($existingPR) {
              Write-Host "Existing PR found: #$($existingPR[0].number)"
              "pr_exists=true" >> $env:GITHUB_OUTPUT
              "pr_number=$($existingPR[0].number)" >> $env:GITHUB_OUTPUT
          } else {
              Write-Host "No existing PR found"
              "pr_exists=false" >> $env:GITHUB_OUTPUT
          }

      - name: Create or update branch
        if: steps.check_packages.outputs.updates_available == 'true'
        shell: pwsh
        run: |
          $branchName = "chore/update-packages"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Check if branch exists locally
          $branchExists = git branch --list $branchName

          if ($branchExists) {
              Write-Host "Checking out existing branch: $branchName"
              git checkout $branchName
              git pull origin main --rebase
          } else {
              Write-Host "Creating new branch: $branchName"
              git checkout -b $branchName
          }

          # Stage and commit changes
          git add src/DLLPickle/Lib/*.dll src/DLLPickle/Lib/Packages.json
          git commit -m "chore(deps): update packages

          ${{ steps.check_packages.outputs.update_summary }}

          Updates to tracked dependencies from NuGet.org"

          # Force push to update the branch (safe since this is a bot-managed branch)
          git push origin $branchName --force

      - name: Create pull request
        if: steps.check_packages.outputs.updates_available == 'true' && steps.check_pr.outputs.pr_exists == 'false'
        shell: pwsh
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          $branchName = "chore/update-packages"
          $prTitle = "chore(deps): Update tracked packages"
          $prBody = @"
          ## ðŸ“¦ Automated Dependency Update

          This PR updates the following tracked packages to their latest versions:

          ${{ steps.check_packages.outputs.update_summary }}

          ### Details
          - **Source**: Daily scheduled dependency check
          - **Branch**: ``$branchName``
          - **Run ID**: $env:GITHUB_RUN_ID

          ### Next Steps
          1. Review the changes
          2. Ensure tests pass
          3. Merge when ready

          > This PR was automatically created by the dependency update workflow.
          "@

          gh pr create --title $prTitle --body $prBody --head $branchName --base main --draft

      - name: Update existing PR
        if: steps.check_packages.outputs.updates_available == 'true' && steps.check_pr.outputs.pr_exists == 'true'
        shell: pwsh
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          $prNumber = "${{ steps.check_pr.outputs.pr_number }}"
          Write-Host "Updating existing PR #$prNumber"

          # Comment on the PR about the update
          $comment = @"
          ðŸ”„ **Updated with latest package changes**

          ${{ steps.check_packages.outputs.update_summary }}

          Run ID: $env:GITHUB_RUN_ID
          "@

          gh pr comment $prNumber --body $comment

      - name: Summary
        if: always()
        shell: pwsh
        run: |
          $summary = @"
          ## Dependency Update Summary

          **Updates Available:** ${{ steps.check_packages.outputs.updates_available }}

          **Changes:** ${{ steps.check_packages.outputs.update_summary }}

          **PR Status:** ${{ steps.check_pr.outputs.pr_exists == 'true' && 'Updated existing PR' || steps.check_packages.outputs.updates_available == 'true' && 'Created new PR' || 'No PR needed' }}

          Run ID: $env:GITHUB_RUN_ID
          "@

          Add-Content -Path $env:GITHUB_STEP_SUMMARY -Value $summary

